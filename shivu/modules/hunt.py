from pyrogram import Client, filters
from telegram.ext import CommandHandler, CallbackContext, CallbackQueryHandler
from pyrogram.types import CallbackQuery
from telegram import InlineKeyboardMarkup, InlineKeyboardButton, Update
from pymongo import MongoClient
from telegram.error import RetryAfter
from datetime import datetime, timedelta
import random
import time
import logging
import traceback
from collections import defaultdict
import asyncio
from shivu import user_collection, collection, application, safari_cooldown_collection, safari_users_collection
from shivu import shivuu as app


logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


sessions = {}
safari_users = {}
allowed_group_id = -1002466950912
current_hunts = {}
current_engagements = {}

# Initialize user_locks as a defaultdict of asyncio.Lock
user_locks = defaultdict(asyncio.Lock)

async def get_random_waifu():
    target_rarities = ['üîÆ Limited Edition', 'ü´ß Premium']  # Example rarities
    selected_rarity = random.choice(target_rarities)
    try:
        pipeline = [
            {'$match': {'rarity': selected_rarity}},
            {'$sample': {'size': 1}}
        ]
        cursor = collection.aggregate(pipeline)
        characters = await cursor.to_list(length=None)
        if characters:
            waifu = characters[0]
            waifu_id = waifu['id']
            # Add waifu to sessions
            sessions[waifu_id] = waifu
            return waifu
        else:
            return None
    except Exception as e:
        print(e)
        return None

async def load_safari_users():
    async for user_data in safari_users_collection.find():
        safari_users[user_data['user_id']] = {
            'safari_balls': user_data['safari_balls'],
            'hunt_limit': user_data['hunt_limit'],
            'used_hunts': user_data['used_hunts']
        }

async def save_safari_user(user_id):
    user_data = safari_users[user_id]
    await safari_users_collection.update_one(
        {'user_id': user_id},
        {'$set': user_data},
        upsert=True
    )

async def safe_send_message(bot, chat_id, text):
    retry_after = 0
    while True:
        try:
            return await bot.send_message(chat_id=chat_id, text=text)
        except RetryAfter as e:
            retry_after = e.retry_after
            logger.warning(f"Flood control exceeded. Retrying in {retry_after} seconds.")
            await asyncio.sleep(retry_after)

async def enter_safari(update: Update, context: CallbackContext):
    message = update.message
    user_id = message.from_user.id

    if user_id in safari_users:
        await safe_send_message(
            context.bot,
            message.chat_id,
            "‚ö†Ô∏è  ô·¥Ä·¥ã·¥Ä!  è·¥è·¥ú' Ä·¥á ·¥Ä ü Ä·¥á·¥Ä·¥Ö è ·¥°…™·¥õ ú…™…¥ ·¥õ ú·¥á s·¥á…™·¥¢·¥á ·¥¢·¥è…¥·¥á, ·¥è…¥…™…™-·¥Ñ ú·¥Ä…¥! ·¥ò ü·¥á·¥Äs·¥á  ô·¥á ·¥ò·¥Ä·¥õ…™·¥á…¥·¥õ~"
        )
        return

    current_time = time.time()

    cooldown_doc = await safari_cooldown_collection.find_one({'user_id': user_id})

    if cooldown_doc:
        last_entry_time = cooldown_doc['last_entry_time']
    else:
        last_entry_time = 0

    cooldown_duration = 5 * 60 * 60  # 5 hours in seconds

    if current_time - last_entry_time < cooldown_duration:
        remaining_time = int(cooldown_duration - (current_time - last_entry_time))
        hours = remaining_time // 3600
        minutes = (remaining_time % 3600) // 60
        await safe_send_message(
            context.bot,
            message.chat_id,
            f"‚è≥ ·¥ã·¥Ä·¥°·¥Ä…™…™~! ·¥Ñ·¥è·¥è ü·¥Ö·¥è·¥°…¥ ·¥Ä·¥Ñ·¥õ…™·¥†·¥á, s·¥á…¥·¥ò·¥Ä…™.  è·¥è·¥ú' ü ü  ô·¥á ·¥Ä ô ü·¥á ·¥õ·¥è  Ä·¥á-·¥á…¥·¥õ·¥á Ä …™…¥ {hours} ú {minutes}·¥ç. …¢·¥Ä…¥ ô·¥Ä·¥õ·¥õ·¥á ·¥ã·¥ú·¥Ö·¥Äs·¥Ä…™ (·¥Ö·¥è  è·¥è·¥ú Ä  ô·¥ás·¥õ) ·¥ú…¥·¥õ…™ ü ·¥õ ú·¥á…¥!"
        )
        return

    user_data = await user_collection.find_one({'id': user_id})
    if user_data is None:
        await safe_send_message(
            context.bot,
            message.chat_id,
            "üö∑ ·¥Ä Ä·¥Ä ·¥Ä Ä·¥Ä~! …™·¥õ s·¥á·¥á·¥çs  è·¥è·¥ú' Ä·¥á …¥·¥è·¥õ  Ä·¥á…¢…™s·¥õ·¥á Ä·¥á·¥Ö, ·¥Ö·¥Ä Ä ü…™…¥…¢. ·¥ò ü·¥á·¥Äs·¥á  Ä·¥á…¢…™s·¥õ·¥á Ä  ô è s·¥õ·¥Ä Ä·¥õ…™…¥…¢ ·¥õ ú·¥á  ô·¥è·¥õ …™…¥ ·¥Ä ·¥Ö…™ Ä·¥á·¥Ñ·¥õ ·¥ç·¥áss·¥Ä…¢·¥á. ·¥ú·¥°·¥ú"
        )
        return

    entry_fee = 10
    if user_data.get('tokens', 10) < entry_fee:
        await safe_send_message(
            context.bot,
            message.chat_id,
            "üí∞ …¥·¥Ä…¥…™!? …™…¥s·¥ú“ì“ì…™·¥Ñ…™·¥á…¥·¥õ ·¥õ·¥è·¥ã·¥á…¥s, s·¥á…¥·¥ò·¥Ä…™!  è·¥è·¥ú …¥·¥á·¥á·¥Ö 10 ·¥õ·¥è·¥ã·¥á…¥s ·¥õ·¥è ·¥á…¥·¥õ·¥á Ä ·¥õ ú·¥á s·¥á…™·¥¢·¥á ·¥¢·¥è…¥·¥á. ·¥õ Ä è  ú·¥Ä Ä·¥Ö·¥á Ä, …¥·¥á~!"
        )
        return

    new_tokens = user_data['tokens'] - entry_fee
    await user_collection.update_one({'id': user_id}, {'$set': {'tokens': new_tokens}})

    await safari_cooldown_collection.update_one(
        {'user_id': user_id},
        {'$set': {'last_entry_time': current_time}},
        upsert=True
    )

    safari_users[user_id] = {
        'safari_balls': 30,
        'hunt_limit': 30,
        'used_hunts': 0
    }

    await save_safari_user(user_id)

    await safe_send_message(
        context.bot,
        message.chat_id,
        "ü•Ç  è·¥Ä·¥õ·¥õ·¥Ä! ·¥°·¥á ü·¥Ñ·¥è·¥ç·¥á ·¥õ·¥è ·¥õ ú·¥á s·¥á…™·¥¢·¥á ·¥¢·¥è…¥·¥á, ·¥ã·¥Ä·¥°·¥Ä…™…™ s·¥á…¥·¥ò·¥Ä…™!  è·¥è·¥ú Ä ·¥á…¥·¥õ Ä è “ì·¥á·¥á ·¥è“ì 10 ·¥õ·¥è·¥ã·¥á…¥s  ú·¥Äs  ô·¥á·¥á…¥ ·¥Ö·¥á·¥Ö·¥ú·¥Ñ·¥õ·¥á·¥Ö.\n\n s·¥õ·¥Ä Ä·¥õ  è·¥è·¥ú Ä s·¥ú…¢·¥è…™ ·¥ä·¥è·¥ú Ä…¥·¥á è ·¥°…™·¥õ ú /explore ·¥Ä…¥·¥Ö ·¥Ö…™s·¥Ñ·¥è·¥†·¥á Ä  Ä·¥Ä Ä·¥á ·¥Ñ·¥Ä·¥õ·¥Ñ ú·¥ás!  ú·¥á Ä·¥á‚Äôs ·¥Ä  ü…™·¥õ·¥õ ü·¥á …¢…™“ì·¥õ ·¥õ·¥è …¢·¥á·¥õ  è·¥è·¥ú ·¥áx·¥Ñ…™·¥õ·¥á·¥Ö:\n[.](https://files.catbox.moe/4kgm8n.jpg)"
    )
  
async def exit_safari(update: Update, context: CallbackContext):
    message = update.message
    user_id = message.from_user.id

    if user_id not in safari_users:
        await message.reply_text("‚ö†Ô∏è ·¥áx…™·¥õ ·¥Ö·¥á…¥…™·¥á·¥Ö!  è·¥è·¥ú ·¥Ä Ä·¥á ·¥Ñ·¥ú Ä Ä·¥á…¥·¥õ ü è …¥·¥è·¥õ …™…¥ ·¥õ ú·¥á s·¥á…™·¥¢·¥á ·¥¢·¥è…¥·¥á, ·¥è…¥…™…™-·¥Ñ ú·¥Ä…¥!")
        return

    del safari_users[user_id]
    await safari_users_collection.delete_one({'user_id': user_id})

    # Sending the exit message in parts with anime flair
    await message.reply_text("‚úÖ ·¥ã·¥Ä…™·¥ã·¥Ä ·¥áx…™·¥õ!  è·¥è·¥ú'·¥†·¥á ·¥ò·¥á Ä“ì·¥á·¥Ñ·¥õ ü è ·¥áx…™·¥õ·¥á·¥Ö ·¥õ ú·¥á s·¥á…™·¥¢·¥á ·¥¢·¥è…¥·¥á, ·¥è…¥…™…™-·¥Ñ ú·¥Ä…¥!")
    await asyncio.sleep(1)  # Small delay between messages
    await message.reply_text("·¥Ä…¥·¥Ö ·¥õ ú·¥á s·¥á…™·¥¢·¥á ·¥¢·¥è…¥·¥á ·¥°…™ ü ü ·¥ç…™ss  è·¥è·¥ú, ·¥ã·¥Ä·¥°·¥Ä…™…™ s·¥á…¥·¥ò·¥Ä…™!")
    await asyncio.sleep(1)  # Small delay between messages
    await message.reply_text("·¥ú…¥·¥õ…™ ü …¥·¥áx·¥õ ·¥õ…™·¥ç·¥á, …™·¥õ·¥á·¥ç …™…¥ ·¥è…¥…™…™-·¥Ñ ú·¥Ä…¥!")

async def hunt(update: Update, context: CallbackContext):
    message = update.message
    user_id = message.from_user.id

    async with user_locks[user_id]:
        if user_id not in safari_users:
            await message.reply_text(
                "üö´ *Onii-chan!*  è·¥è·¥ú' Ä·¥á …¥·¥è·¥õ ·¥ò·¥Ä Ä·¥õ ·¥è“ì ·¥õ ú·¥á ·¥ã·¥Ä·¥°·¥Ä…™…™ ·¥Ä·¥Ö·¥†·¥á…¥·¥õ·¥ú Ä·¥á~\n"
                "üå∏ ·¥ä·¥è…™…¥ ·¥ús “ì…™ Äs·¥õ ·¥°…™·¥õ ú /wtour ·¥Ä…¥·¥Ö ·¥ò Ä·¥á·¥ò·¥Ä Ä·¥á “ì·¥è Ä s·¥è·¥ç·¥á ·¥á·¥ò…™·¥Ñ “ì·¥ú…¥!"
            )
            return

        if user_id in current_hunts and current_hunts[user_id] is not None:
            if user_id not in current_engagements:
                await message.reply_text(
                    "‚ö†Ô∏è *Senpai~!* ·¥Ä  ú·¥ú…¥·¥õ …™s ·¥Ä ü Ä·¥á·¥Ä·¥Ö è ·¥ú…¥·¥Ö·¥á Ä·¥°·¥Ä è~\n"
                    "F…™…¥…™s ú ·¥õ ú·¥Ä·¥õ ·¥è…¥·¥á “ì…™ Äs·¥õ  ô·¥á“ì·¥è Ä·¥á ·¥Ö…™·¥†…™…¥…¢ …™…¥·¥õ·¥è ·¥Ä…¥·¥è·¥õ ú·¥á Ä ·¥Ä·¥Ö·¥†·¥á…¥·¥õ·¥ú Ä·¥á!"
                )
                return

        user_data = safari_users[user_id]
        if user_data['used_hunts'] >= user_data['hunt_limit']:
            await message.reply_text(
                "üö∑ *Ara Ara!*  ú·¥ú…¥·¥õ  ü…™·¥ç…™·¥õ  Ä·¥á·¥Ä·¥Ñ ú·¥á·¥Ö~\n"
                "üåü ·¥è·¥ú·¥Ñ ú…™·¥á! ·¥õ…™·¥ç·¥á ·¥õ·¥è ·¥õ·¥Ä·¥ã·¥á ·¥Ä  ô Ä·¥á·¥Ä·¥õ ú·¥á Ä ·¥Ä…¥·¥Ö ·¥Ñ·¥è·¥ç·¥á  ô·¥Ä·¥Ñ·¥ã  ü·¥Ä·¥õ·¥á Ä."
            )
            del safari_users[user_id]
            await safari_users_collection.delete_one({'user_id': user_id})
            return

        if user_data['safari_balls'] <= 0:
            await message.reply_text(
                "üíî *Kawaii!* ·¥õ ú·¥á Ä·¥á'·¥Ö  ô·¥á …¥·¥è ·¥ç·¥è Ä·¥á ·¥Ñ Ä ès·¥õ·¥Ä üs  ü·¥á“ì·¥õ!\n"
                "·¥ç·¥Ä è ô·¥á ·¥õ…™·¥ç·¥á ·¥õ·¥è  Ä·¥á“ì…™ ü ü  è·¥è·¥ú Ä ·¥á…¥·¥á Ä…¢ è  ô·¥Ä Äs ·¥Ä…¥·¥Ö  Ä·¥á·¥õ·¥ú Ä…¥~."
            )
            del safari_users[user_id]
            await safari_users_collection.delete_one({'user_id': user_id})
            return

        waifu = await get_random_waifu()
        if not waifu:
            await message.reply_text(
                "üö´ *Ara!* …¥·¥è ·¥Ñ·¥ú·¥õ…™·¥ás ·¥Ä Ä·¥è·¥ú…¥·¥Ö...\n"
                "·¥Ñ ú·¥á·¥Ñ·¥ã  ô·¥Ä·¥Ñ·¥ã ·¥Ä“ì·¥õ·¥á Ä ·¥Ä ·¥° ú…™ ü·¥á!"
            )
            return

        waifu_name = waifu['name']
        waifu_img_url = waifu['img_url']
        waifu_id = waifu['id']
        waifu_rarity = waifu['rarity']

        if user_id in current_hunts:
            del current_hunts[user_id]

        current_hunts[user_id] = waifu_id

        user_data['used_hunts'] += 1
        safari_users[user_id] = user_data

        await save_safari_user(user_id)

        text = (
            f"üéá *Kyaa~!* ·¥Ä ·¥°…™ ü·¥Ö {waifu_name} ·¥Ä·¥ò·¥ò·¥á·¥Ä Ä·¥á·¥Ö! üå∏\n\n"
            f"ü™Ñ  Ä·¥Ä Ä…™·¥õ è: *{waifu_rarity}*\n"
            f"üç• ·¥áx·¥ò ü·¥è Ä·¥á  ü…™·¥ç…™·¥õ: {user_data['used_hunts']}/{user_data['hunt_limit']}\n"
            f"üíé ·¥Ñ·¥è…¥·¥õ Ä·¥Ä·¥Ñ·¥õ ·¥Ñ Ä ès·¥õ·¥Ä üs  ü·¥á“ì·¥õ: {user_data['safari_balls']}\n\n"
            f"üíå *A·¥°·¥Ä·¥ã·¥á…¥  è·¥è·¥ú Ä ·¥Ä…¥…™·¥ç·¥á s·¥è·¥ú ü ·¥Ä…¥·¥Ö ·¥Ñ·¥Ä·¥õ·¥Ñ ú ·¥õ ú…™s “ì ü·¥ú“ì“ì è ·¥Ö Ä·¥á·¥Ä·¥ç!*"
        )

        keyboard = InlineKeyboardMarkup(
            [
                [InlineKeyboardButton("üé≠ E…¥…¢·¥Ä…¢·¥á …¥·¥è·¥°!", callback_data=f"engage_{waifu_id}_{user_id}")]
            ]
        )

        await message.reply_photo(photo=waifu_img_url, caption=text, reply_markup=keyboard)

        if user_id in current_engagements:
            del current_engagements[user_id]

async def typing_animation(callback_query, text):
    try:
        # Randomly set duration for typing effect
        duration = 3 if random.random() < 0.05 else random.choice([1, 2])

        for i in range(1, duration + 1):
            dots = "üå∏" * i
            await callback_query.message.edit_caption(caption=f"<i>{text} {dots}</i>")
            await asyncio.sleep(1)

        return dots
    except Exception as e:
        logger.error(f"Error in typing_animation: {e}")
        logger.error(traceback.format_exc())
        return "üå∏üå∏üå∏"  # Fallback to ensure flow continues

async def throw_ball(callback_query):
    user_id = int(callback_query.from_user.id)

    async with user_locks[user_id]:
        try:
            data = callback_query.data.split("_")
            waifu_id = data[1]
            original_user_id = int(data[2])

            if original_user_id != user_id:
                await callback_query.answer("‚ùå ·¥è…¥…™·¥Ñ ú·¥Ä…¥~ ·¥õ ú…™s  ú·¥ú…¥·¥õ …™s …¥·¥è·¥õ “ì·¥è Ä  è·¥è·¥ú!", show_alert=True)
                return

            if user_id not in safari_users:
                await callback_query.answer("üö™ ·¥ã·¥Ä·¥°·¥Ä…™…™~  è·¥è·¥ú' Ä·¥á …¥·¥è·¥õ ·¥ò·¥Ä Ä·¥õ ·¥è“ì ·¥õ ú·¥á ·¥Ä·¥Ö·¥†·¥á…¥·¥õ·¥ú Ä·¥á!", show_alert=True)
                return

            if waifu_id not in sessions:
                await callback_query.answer("ü¶ã ·¥Ä Ä·¥Ä ·¥Ä Ä·¥Ä~ ·¥õ ú·¥á ·¥°…™ ü·¥Ö ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á Ä ·¥ás·¥Ñ·¥Ä·¥ò·¥á·¥Ö!", show_alert=True)
                return

            user_data = safari_users[user_id]
            user_data['safari_balls'] -= 1
            safari_users[user_id] = user_data

            await save_safari_user(user_id)

            outcome = await typing_animation(callback_query, "‚ú®  è·¥è·¥ú ·¥ús·¥á·¥Ö ·¥Ä ·¥Ñ·¥è…¥·¥õ Ä·¥Ä·¥Ñ·¥õ ·¥Ñ Ä ès·¥õ·¥Ä ü! üåü\n\n")

            if outcome == "üå∏üå∏üå∏":
                await callback_query.message.edit_caption(
                    caption="üéâ  è·¥Ä·¥õ·¥õ·¥Ä~!  è·¥è·¥ú ·¥Ñ·¥Ä·¥ò·¥õ·¥ú Ä·¥á·¥Ö ·¥õ ú·¥á ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á Ä! üç•"
                )

                character = sessions[waifu_id]
                await user_collection.update_one({'id': user_id}, {'$push': {'characters': character}})

                del sessions[waifu_id]

            else:
                await callback_query.message.edit_caption(
                    caption="üòî ·¥è ú …¥·¥è~  è·¥è·¥ú ·¥ç…™ss·¥á·¥Ö! ·¥õ ú·¥á ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á Ä “ì ü·¥á·¥Ö …™…¥·¥õ·¥è ·¥õ ú·¥á ·¥°…™ ü·¥Ö! üåÄ"
                )
                del sessions[waifu_id]

            if user_data['safari_balls'] <= 0:
                await callback_query.message.edit_caption(
                    caption="‚ö†Ô∏è  ú·¥Ä Ä…™·¥ã·¥è…¥·¥á~  è·¥è·¥ú  Ä·¥Ä…¥ ·¥è·¥ú·¥õ ·¥è“ì ·¥Ñ·¥è…¥·¥õ Ä·¥Ä·¥Ñ·¥õ ·¥Ñ Ä ès·¥õ·¥Ä üs!"
                )
                del safari_users[user_id]
                await safari_users_collection.delete_one({'user_id': user_id})

            del current_hunts[user_id]

        except Exception as e:
            logger.error(f"An error occurred in throw_ball: {e}")
            logger.error(traceback.format_exc())
            await callback_query.answer("üîß A·¥ã…™ Ä·¥Ä~! A…¥ ·¥á Ä Ä·¥è Ä ·¥è·¥Ñ·¥Ñ·¥ú Ä Ä·¥á·¥Ö. P ü·¥á·¥Äs·¥á ·¥õ Ä è ·¥Ä…¢·¥Ä…™…¥.", show_alert=True)

async def run_away(callback_query):
    user_id = int(callback_query.from_user.id)

    async with user_locks[user_id]:
        try:
            data = callback_query.data.split("_")
            waifu_id = data[1]
            original_user_id = int(data[2])

            if original_user_id != user_id:
                await callback_query.answer("‚ùå ·¥ç·¥Ä·¥Ö·¥Ä ·¥ç·¥Ä·¥Ö·¥Ä~ ·¥õ ú…™s …™s …¥·¥è·¥õ “ì·¥è Ä  è·¥è·¥ú!", show_alert=True)
                return

            if user_id not in safari_users:
                await callback_query.answer("üö´ ·¥ã·¥Ä·¥°·¥Ä…™…™~  è·¥è·¥ú' Ä·¥á …¥·¥è·¥õ ·¥á·¥†·¥á…¥ …™…¥ ·¥õ ú·¥á …¢·¥Ä·¥ç·¥á!", show_alert=True)
                return

            del sessions[waifu_id]
            del current_hunts[user_id]

            await callback_query.message.edit_caption(caption="üèÉ‚Äç‚ôÇÔ∏è A Ä…™…¢·¥Ä·¥õ·¥è~  è·¥è·¥ú s ü…™·¥ò·¥ò·¥á·¥Ö ·¥Ä·¥°·¥Ä è “ì Ä·¥è·¥ç ·¥õ ú·¥á ·¥°…™ ü·¥Ö ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á Ä! üå™Ô∏è")
            await callback_query.answer("‚ú® ·¥ç·¥Ä·¥ä…™~  è·¥è·¥ú'·¥†·¥á ·¥ç·¥Ä·¥Ö·¥á ·¥Ä ·¥Ñ ü·¥á·¥†·¥á Ä ·¥ás·¥Ñ·¥Ä·¥ò·¥á!", show_alert=True)

        except Exception as e:
            logger.error(f"Error handling run_away: {e}")
            await callback_query.answer("‚ö†Ô∏è S·¥è Ä Ä è ·¥è…¥…™·¥Ñ ú·¥Ä…¥~ S·¥è·¥ç·¥á·¥õ ú…™…¥…¢ ·¥°·¥á…¥·¥õ ·¥° Ä·¥è…¥…¢. T Ä è ·¥Ä…¢·¥Ä…™…¥  ü·¥Ä·¥õ·¥á Ä!", show_alert=True)

async def engage(callback_query):
    user_id = int(callback_query.from_user.id)

    async with user_locks[user_id]:
        try:
            data = callback_query.data.split("_")
            waifu_id = data[1]
            original_user_id = int(data[2])

            if original_user_id != user_id:
                await callback_query.answer("‚ùå Ara-ara~ This hunt isn‚Äôt yours, onii-chan!", show_alert=True)
                return

            if user_id not in safari_users:
                await callback_query.answer("üö´ Baka! You‚Äôre not even in the kawaii hunting zone!", show_alert=True)
                return

            if waifu_id not in sessions:
                await callback_query.answer("ü¶ã Kyaa~ The wild character escaped! Sugoi speed!", show_alert=True)
                return

            if user_id in current_engagements:
                del current_engagements[user_id]

            if user_id in current_hunts and current_hunts[user_id] == waifu_id:
                waifu = sessions[waifu_id]
                waifu_name = waifu['name']
                waifu_img_url = waifu['img_url']

                text = (
                    f"‚öîÔ∏è Kyaa~ It‚Äôs {waifu_name}! \n\n"
                    f"‚ú® Choose your action, senpai! Will you fight bravely or run like a scared neko? üòº"
                )
                keyboard = InlineKeyboardMarkup(
                    [
                        [
                            InlineKeyboardButton("üå∏ Throw Kawaii Petal üå∏", callback_data=f"throw_{waifu_id}_{user_id}"),
                            InlineKeyboardButton("üèÉ‚Äç‚ôÇÔ∏è Run like Deku!", callback_data=f"run_{waifu_id}_{user_id}")
                        ]
                    ]
                )
                await callback_query.message.edit_caption(caption=text, reply_markup=keyboard)
                await callback_query.answer("üå∏ Onii-chan, choose wisely! Faito dayo~!")

                current_engagements[user_id] = waifu_id

            else:
                await callback_query.answer("ü¶ã Sugoi~ The wild character has fled! üò≠", show_alert=True)

        except Exception as e:
            logger.error(f"Error handling engage: {e}")
            await callback_query.answer("‚ö†Ô∏è Oh no, senpai! Something went wrong. Try again later.", show_alert=True)


async def hunt_callback_query(update: Update, context: CallbackContext):
    callback_query = update.callback_query
    data = callback_query.data.split("_")
    action = data[0]
    waifu_id = data[1]
    user_id = int(data[2])

    if action == "engage":
        await engage(callback_query)
    elif action == "throw":
        await throw_ball(callback_query)
    elif action == "run":
        await run_away(callback_query)


async def dc_command(update: Update, context: CallbackContext):
    # Check if the command is a reply to a message
    if not update.message.reply_to_message:
        await update.message.reply_text("üîÑ Oops! You need to reply to reset the cooldown for that user.")
        return

    replied_user_id = update.message.reply_to_message.from_user.id

    # Replace with your authorized user_id
    authorized_user_id = 6402009857

    if update.message.from_user.id != authorized_user_id:
        await update.message.reply_text("üö´ Baka! Only the senpai can use this command.")
        return

    try:
        result = await safari_cooldown_collection.delete_one({'user_id': replied_user_id})

        if result.deleted_count == 1:
            await update.message.reply_text(f"‚úÖ Cooldown reset for user {replied_user_id}. You‚Äôre sugoi!")
        else:
            await update.message.reply_text(f"‚ö†Ô∏è Hmm, user {replied_user_id} doesn‚Äôt have any cooldowns.")
    
    except Exception as e:
        logger.error(f"Error resetting safari cooldown for user {replied_user_id}: {e}")
        await update.message.reply_text("‚ö†Ô∏è Ara-ara~ Something went wrong. Try again, senpai.")


# Adding the command handlers
application.add_handler(CommandHandler("dc", dc_command))
application.add_handler(CommandHandler("wtour", enter_safari))
application.add_handler(CommandHandler("exit", exit_safari))
application.add_handler(CommandHandler("explore", hunt))
application.add_handler(CallbackQueryHandler(hunt_callback_query, pattern="^(engage|throw|run)_", block=False))
